package main

import (
	"bufio"
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	"strings"
	"sync"
	"time"
)

var mirrors []string
var waitGroup sync.WaitGroup

func main() {
	countFlag := flag.Int("C", 5, "Count of mirrors\nEx: mirrorlist -C <count>")
	flag.Parse()

	response, exception := http.Get("https://www.archlinux.org/mirrorlist/all")
	if exception != nil {
		log.Fatal(exception.Error())
	}

	responseBinary, exception := io.ReadAll(response.Body)
	if exception != nil {
		log.Fatal(exception.Error())
	}

	response.Body.Close()
	responseString := strings.TrimSpace(string(responseBinary))
	scanner := bufio.NewScanner(strings.NewReader(responseString))
	for scanner.Scan() {
		if scanner.Text() != "" && !strings.HasPrefix(scanner.Text(), "##") {
			mirrors = append(mirrors, strings.Replace(strings.Replace(scanner.Text(), "#Server = ", "", -1), "/$repo/os/$arch", "", -1))
		}
	}

	sortedMirrors := make(chan string, *countFlag)
	waitGroup.Add(*countFlag)
	for _, v := range mirrors {
		go sortMirrors(v, sortedMirrors)
	}

	waitGroup.Wait()
	close(sortedMirrors)

	for v := range sortedMirrors {
		fmt.Println(v)
	}

	fmt.Println("# Generated by github.com/enindu/mirrorlist")
}

func sortMirrors(m string, c chan string) {
	startTime := time.Now()
	http.Get(m)
	endTime := time.Since(startTime).Seconds()
	c <- fmt.Sprintf("# %f\nServer = %s/$repo/os/$arch", endTime, m)
	waitGroup.Done()
}
