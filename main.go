package main

import (
	"bufio"
	"flag"
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"
	"time"

	log "github.com/sirupsen/logrus"
)

var (
	allMirrors    []string
	sortedMirrors []string
)

func main() {
	// Set command line flags
	mirrorsCount := flag.Int("count", 3, "Mirrors count")
	responseTime := flag.Float64("max", 1, "Maximum response time of a mirror (In seconds)")
	mirrorlistURL := flag.String("url", "https://www.archlinux.org/mirrorlist/all", "Mirrorlist URL")

	flag.Parse()

	// Get response from mirrorlist URL
	response, errors := http.Get(*mirrorlistURL)

	if errors != nil {
		log.Fatal(errors)
	}

	// Convert mirrorlist URL response body to bytes
	responseBytes, errors := ioutil.ReadAll(response.Body)

	if errors != nil {
		log.Fatal(errors)
	}

	// Close response body
	response.Body.Close()

	// Convert mirrorlist URL bytes to a string
	responseString := strings.TrimSpace(string(responseBytes))

	// Get mirrors one by one from mirrorlist URL string
	scanner := bufio.NewScanner(strings.NewReader(responseString))

	for scanner.Scan() {
		if !strings.HasPrefix(scanner.Text(), "##") && scanner.Text() != "" {
			allMirrors = append(allMirrors, strings.Replace(strings.Replace(scanner.Text(), "#Server = ", "", -1), "/$repo/os/$arch", "", -1))
		}
	}

	// Get and sort mirrors from all mirrors slice
	for _, mirror := range allMirrors {
		start := time.Now()
		_, errors := http.Get(mirror)
		end := time.Now().Sub(start).Seconds()

		if errors != nil || end >= *responseTime {
			continue
		}

		if end < *responseTime {
			sortedMirrors = append(sortedMirrors, mirror)
		}

		if len(sortedMirrors) == *mirrorsCount {
			break
		}
	}

	// Print sorted mirrors
	for _, mirror := range sortedMirrors {
		fmt.Printf("Server = %s/$repo/os/$arch\n", mirror)
	}

	// Print footer notes
	fmt.Println("# Generated by github.com/enindu/mirrorlist")
}
