package main

import (
	"bufio"
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	"strings"
	"sync"
	"time"
)

var waitGroup sync.WaitGroup

func main() {
	urlFlag := flag.String("U", "https://www.archlinux.org/mirrorlist/all", "Mirrorlist URL\nEx: mirrorlist -U <url>")
	countFlag := flag.Int("C", 5, "Mirrors count\nEx: mirrorlist -C <count>")

	flag.Parse()

	response, exception := http.Get(*urlFlag)
	if exception != nil {
		log.Fatal(exception.Error())
	}

	defer response.Body.Close()

	responseBinary, exception := io.ReadAll(response.Body)
	if exception != nil {
		log.Fatal(exception.Error())
	}

	responseString := strings.TrimSpace(string(responseBinary))

	mirrors := make([]string, 0)

	scanner := bufio.NewScanner(strings.NewReader(responseString))
	for scanner.Scan() {
		if scanner.Text() != "" && !strings.HasPrefix(scanner.Text(), "##") {
			mirrors = append(mirrors, strings.Replace(strings.Replace(scanner.Text(), "#Server = ", "", -1), "/$repo/os/$arch", "", -1))
		}
	}

	sortedMirrors := make(chan string, *countFlag)

	waitGroup.Add(*countFlag)

	for _, v := range mirrors {
		go sortMirrors(v, sortedMirrors)
	}

	waitGroup.Wait()

	close(sortedMirrors)

	for v := range sortedMirrors {
		fmt.Println(v)
	}

	fmt.Println("# Generated by https://github.com/enindu/mirrorlist")
}

func sortMirrors(m string, c chan string) {
	startTime := time.Now()

	http.Get(m)

	endTime := time.Since(startTime).Seconds()

	c <- fmt.Sprintf("# %f\nServer = %s/$repo/os/$arch", endTime, m)

	waitGroup.Done()
}
