// This file is part of mirrorlist.
// Copyright (C) 2024 Enindu Alahapperuma
//
// mirrorlist is free software: you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free Software
// Foundation, either version 3 of the License, or (at your option) any later
// version.
//
// mirrorlist is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
// A PARTICULAR PURPOSE. See the GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along with
// mirrorlist. If not, see <https://www.gnu.org/licenses/>.

package main

import (
	"bufio"
	"cmp"
	"flag"
	"fmt"
	_http "net/http"
	_url "net/url"
	"slices"
	"strings"
	"sync"
	"time"

	"github.com/enindu/palette"
)

const (
	allMirrorListUrl   string = "https://archlinux.org/mirrorlist/all"
	httpMirrorListUrl  string = "https://archlinux.org/mirrorlist/all/http"
	httpsMirrorListUrl string = "https://archlinux.org/mirrorlist/all/https"
)

func main() {
	// Define execution start time.
	start := time.Now()

	// Create printers.
	warn := palette.NewPrinterWarn()
	erro := palette.NewPrinterErro()

	// Create flags.
	http := flag.Bool("http", false, "Use only HTTP mirrors to generate.")
	https := flag.Bool("https", false, "Use only HTTPS mirrors to generate.")
	count := flag.Int("count", 5, "Count of mirrors to generate.")
	pings := flag.Int("pings", 5, "Pings per a mirror. Higher pings means precise results, but high execution time.")
	verbose := flag.Bool("verbose", false, "Omit errors, warnings, and informations from output.")
	flag.Parse()

	// Check if both -http and -https flags used.
	if *http && *https {
		erro.Write("ERRO could not run mirrorlist, because both -http and -https flags are used.\n")
		return
	}

	// Create mirror list URL.
	mirrorListUrl := allMirrorListUrl
	if *http {
		mirrorListUrl = httpMirrorListUrl
	}
	if *https {
		mirrorListUrl = httpsMirrorListUrl
	}

	// Get response from mirror list URL.
	mirrorListResponse, fault := _http.Get(mirrorListUrl)
	if fault != nil {
		erro.Write("ERRO could not run mirrorlist, because %s is not responding.\n", mirrorListUrl)
		return
	}
	defer mirrorListResponse.Body.Close()

	// Create mirror URLs.
	mirrorUrls := []string{}
	mirrorListScanner := bufio.NewScanner(mirrorListResponse.Body)
	for mirrorListScanner.Scan() {
		// Create mirror URL.
		url := mirrorListScanner.Text()
		url = strings.TrimSpace(url)
		url = strings.TrimPrefix(url, "#Server = ")
		url = strings.TrimSuffix(url, "/$repo/os/$arch")
		if url == "" {
			continue
		}
		if strings.HasPrefix(url, "##") {
			continue
		}

		// Parse mirror URL.
		parseUrl, fault := _url.Parse(url)
		if fault != nil {
			if *verbose {
				warn.Write("WARN could not parse %s\n", url)
			}
			continue
		}
		url = parseUrl.String()

		// Store mirror URL.
		mirrorUrls = append(mirrorUrls, url)
	}

	// Ping mirror URLs and store URL and time.
	mirrorUrlsLength := len(mirrorUrls)
	mirrorsChannel := make(chan mirror, mirrorUrlsLength)
	wait := sync.WaitGroup{}
	wait.Add(mirrorUrlsLength)
	for _, mirrorUrl := range mirrorUrls {
		go ping(&wait, mirrorsChannel, mirrorUrl, *pings, *verbose)
	}
	wait.Wait()
	close(mirrorsChannel)

	// Get mirrors.
	mirrors := []mirror{}
	for mirror := range mirrorsChannel {
		mirrors = append(mirrors, mirror)
	}

	// Sort mirrors by time.
	slices.SortFunc(mirrors, func(x mirror, y mirror) int {
		return cmp.Compare(x.time, y.time)
	})

	// Print mirrors as in /etc/pacman.d/mirrorlist.
	for _, item := range mirrors[:*count] {
		fmt.Printf("# %f\n", item.time)
		fmt.Printf("Server = %s/$repo/os/$arch\n", item.url)
	}

	// Define execution end time.
	end := time.Since(start).Seconds()

	// Print information messages.
	fmt.Printf("## Executed in %.2f seconds\n", end)
	fmt.Printf("## Generated by mirrorlist\n")
}

func ping(wait *sync.WaitGroup, mirrorsChannel chan mirror, mirrorUrl string, pings int, verbose bool) {
	// Defer wait done.
	defer wait.Done()

	// Create printers.
	warn := palette.NewPrinterWarn()

	// Ping mirror URL (1 x pings time).
	end := time.Duration(0)
	for i := 0; i < pings; i++ {
		start := time.Now()
		response, fault := _http.Get(mirrorUrl)
		if fault != nil {
			if verbose {
				warn.Write("WARN could not get response from %s.\n", mirrorUrl)
			}
			return
		}
		defer response.Body.Close()
		if response.StatusCode != _http.StatusOK {
			return
		}
		end = end + time.Since(start)
	}
	if end == 0 {
		return
	}

	// Send mirror to mirrors channel.
	mirrorsChannel <- mirror{
		url:  mirrorUrl,
		time: end.Seconds() / float64(pings),
	}
}
