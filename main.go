package main

import (
	"bufio"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"sort"
	"strings"
	"time"
)

func main() {
	var (
		mirrors        []string
		executionTimes []float64
	)

	start := time.Now()
	count := flag.Int("c", 3, "Count of mirrors")
	maxTime := flag.Float64("m", 1, "Maximum response time (In seconds) of a mirror")
	url := flag.String("u", "https://www.archlinux.org/mirrorlist/all", "Mirrorlist URL")

	flag.Parse()

	response, errors := http.Get(*url)

	if errors != nil {
		log.Fatal("Error:", errors)
	}

	bytes, errors := ioutil.ReadAll(response.Body)

	if errors != nil {
		log.Fatal("Error:", errors)
	}

	response.Body.Close()

	body := strings.TrimSpace(string(bytes))
	scanner := bufio.NewScanner(strings.NewReader(body))

	for scanner.Scan() {
		if !strings.HasPrefix(scanner.Text(), "##") && scanner.Text() != "" {
			mirrors = append(mirrors, strings.Replace(strings.Replace(scanner.Text(), "#Server = ", "", -1), "/$repo/os/$arch", "", -1))
		}
	}

	sortedMirrors := make(map[float64]string)

	for _, mirror := range mirrors {
		start := time.Now()
		_, errors := http.Get(mirror)
		end := time.Now().Sub(start).Seconds()

		if errors != nil || end >= *maxTime {
			continue
		}

		if len(sortedMirrors) == *count {
			break
		}

		if end < *maxTime {
			sortedMirrors[end] = mirror
		}
	}

	for key := range sortedMirrors {
		executionTimes = append(executionTimes, key)
	}

	sort.Float64s(executionTimes)

	for _, executionTime := range executionTimes {
		fmt.Printf("Server = %s/$repo/os/$arch\n", sortedMirrors[executionTime])
	}

	end := time.Now().Sub(start).Seconds()

	fmt.Println("# Generated by github.com/enindu/mirrorlist")
	fmt.Println("# Total execution time:", end)
}
